"""
ExaBGP集成服务：根据数据库中的BGP会话与宣告生成配置并应用
"""
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
import os
import logging

from ..models.bgp import BGPSession as BGPSessionModel, BGPAnnouncement as BGPAnnouncementModel

logger = logging.getLogger(__name__)


class ExaBGPService:
    def __init__(self, db: AsyncSession, config_path: str = "/etc/exabgp/exabgp.conf"):
        self.db = db
        self.config_path = config_path

    async def generate_config(self) -> str:
        """
        生成ExaBGP配置（简化版本）。
        每个会话对应一个neighbor配置，宣告在对应neighbor中以announce route形式呈现。
        """
        result = await self.db.execute(select(BGPSessionModel))
        sessions: List[BGPSessionModel] = result.scalars().all()

        result = await self.db.execute(select(BGPAnnouncementModel))
        announcements: List[BGPAnnouncementModel] = result.scalars().all()

        # 将宣告按会话分组（未绑定会话的宣告归为全局）
        grouped: dict[str, List[BGPAnnouncementModel]] = {}
        for ann in announcements:
            key = str(ann.session_id) if ann.session_id else "__global__"
            grouped.setdefault(key, []).append(ann)

        lines: List[str] = []
        lines.append("# Generated by IPv6 WireGuard Manager")
        for sess in sessions:
            if not sess.enabled:
                continue
            lines.append(f"neighbor {sess.neighbor} {{")
            lines.append(f"  router-id 1.1.1.1;")
            lines.append(f"  local-as {sess.remote_as};")
            lines.append(f"  peer-as {sess.remote_as};")
            if sess.password:
                lines.append(f"  md5 {sess.password};")
            lines.append("}")

            key = str(sess.id)
            for ann in grouped.get(key, []):
                if not ann.enabled:
                    continue
                nh = f" next-hop {ann.next_hop}" if ann.next_hop else ""
                lines.append(f"announce route {ann.prefix}{nh}")

        # 全局宣告（无会话）
        for ann in grouped.get("__global__", []):
            if not ann.enabled:
                continue
            nh = f" next-hop {ann.next_hop}" if ann.next_hop else ""
            lines.append(f"announce route {ann.prefix}{nh}")

        return "\n".join(lines) + "\n"

    async def apply_config(self) -> bool:
        """写入配置文件，留待运维层面触发重载（或后续增加重载操作）"""
        try:
            config = await self.generate_config()
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            with open(self.config_path, "w", encoding="utf-8") as f:
                f.write(config)
            logger.info(f"ExaBGP配置已写入: {self.config_path}")
            return True
        except Exception as e:
            logger.error(f"写入ExaBGP配置失败: {e}")
            return False

    async def get_status(self) -> dict:
        """
        返回简化状态；后续可接入真实exabgp运行状态（例如通过进程/套接字查询）。
        """
        try:
            exists = os.path.exists(self.config_path)
            return {"exabgp": "configured" if exists else "not_configured", "config_path": self.config_path}
        except Exception:
            return {"exabgp": "unknown", "config_path": self.config_path}